#include "llvm/Passes/PassPlugin.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Constants.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

namespace {
struct HayakuPass : public PassInfoMixin<HayakuPass> {
  PreservedAnalyses run(Module &M, ModuleAnalysisManager &) {
    Function *MainFunc = M.getFunction("main");
    if (!MainFunc) return PreservedAnalyses::all();

    LLVMContext &Ctx = M.getContext();
    IRBuilder<> Builder(&*MainFunc->getEntryBlock().getFirstInsertionPt());

    // 1. 呼叫 debug(48763)
    FunctionCallee DebugFn = M.getOrInsertFunction("debug", 
        FunctionType::get(Type::getVoidTy(Ctx), {Type::getInt32Ty(Ctx)}, false));
    Value *DebugVal = ConstantInt::get(Type::getInt32Ty(Ctx), 48763);
    Builder.CreateCall(DebugFn, DebugVal);

    // 2. main(int argc, char **argv) => 改寫 argv[1]
    auto ArgIter = MainFunc->arg_begin();
    Argument *Argc = &*ArgIter++;
    Argument *Argv = &*ArgIter;

    // argv[1] = "hayaku... motohayaku!"
    Value *StrConst = Builder.CreateGlobalStringPtr("hayaku... motohayaku!", "hayaku_str");
    Value *Index1 = ConstantInt::get(Type::getInt32Ty(Ctx), 1);
    Value *Argv1Ptr = Builder.CreateGEP(Argv->getType()->getPointerElementType(), Argv, Index1);
    Builder.CreateStore(StrConst, Argv1Ptr);

    // 3. argc = 48763
    Value *FakeArgcVal = ConstantInt::get(Type::getInt32Ty(Ctx), 48763);
    AllocaInst *ArgcStorage = Builder.CreateAlloca(Type::getInt32Ty(Ctx), nullptr, "argc_fake");
    Builder.CreateStore(FakeArgcVal, ArgcStorage);
    for (auto &U : llvm::make_early_inc_range(Argc->uses())) {
      U.set(Builder.CreateLoad(Type::getInt32Ty(Ctx), ArgcStorage));
    }

    return PreservedAnalyses::none();
  }
};
} // namespace

// 註冊 Plugin
extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() {
  static const PassPluginLibraryInfo Info{
    LLVM_PLUGIN_API_VERSION, "HayakuPass", LLVM_VERSION_STRING,
    [](PassBuilder &PB) {
      PB.registerPipelineParsingCallback([](StringRef Name, ModulePassManager &MPM, ArrayRef<PassBuilder::PipelineElement>) {
        if (Name == "hayaku-pass") {
          MPM.addPass(HayakuPass());
          return true;
        }
        return false;
      });
    }
  };
  return Info;
}
